# docker 介绍
	介绍优势
	介绍常用应用
    介绍原理
        隔离 容器 host
        只能原生跑在 linux 上
        mac 新版用 hypervisor，不稳定
        win 新版也用 hypervisor 但还在测试
        win 旧版本的好处是省略了 linux kernal，简单稳定。新的就是快。
        

# 用 docker 部署一个简单的 flask 应用
## 在本地跑起一个 flask 应用
flask run
## 在本地用 docker 跑起这个应用
### docker 安装
### 镜像 容器 仓库
docker for windows setting 里面改镜像
registry mirrors
https://registry.docker-cn.com

docker pull ubuntu:xenial

- 容器开关 进入退出 
docker run -it ubuntu
docker attach
docker exec

docker ps
docker images

docker stop
docker rm
docker rmi

后台运行
docker run -t -d ubuntu
docker exec -i -t flask bash

- 网络 端口转发
- 普通跑 
docker run -t -d -p 5000:5000 --name flask ubuntu:xenial
docker cp run.sh "flask:/root/run.sh"
docker cp app.py "flask:/root/app.py"
docker cp sources.list "flask:/root/sources.list"
docker cp pip.conf "flask:/root/pip.conf"
docker exec -i -t flask bash -ex /root/run.sh
docker exec -d flask bash -ex /root/run.sh

- dockerfile 跑

docker build -t flask .
docker run -p 5000:5000 --name flask flask


### 在服务器用 docker 跑起这个应用
- docker 安装

换 apt docker 源
/etc/apt/sources.list
deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu xenial stable

换 docker hub 源
https://www.docker-cn.com/registry-mirror


- 服务器 docker 部署
--sig-proxy=false
Control+C 会被发送给 docker 而不是 entroypoint 中的程序，这样就能 detach

docker run -p 80:5000 --name flask --sig-proxy=false flask

- 开发部署环境一致化

用 tag 发版本
docker build -t flask:0523 -t flask:latest .
这样重新 build 的话速度非常快 

dockerfile 命令的顺序很重要，前面有改变，后面会全部重新 build

- systemd vs docker
非常复杂 谁也不兼容对方

# 给 docker 加入数据库
    
- 本地部署之后服务器部署
- 演示为何需要数据卷
- 用数据卷启动服务器

Dockerfile 需要指定 VOLUME
指定 VOLUME 后
如果没有 -v run 的时候 docker 会把 VOLUME 后面的文件夹中的数据从 image 中复制出来，形成匿名卷
如果有 -v，则只会在第一次 run 的时候复制文件

docker volume create flask-volume
docker run -p 5000:5000 --name flask --mount source=flask-volume,target=/data flask
docker run -p 80:5000 --name flask --mount source=flask-volume,target=/data  --sig-proxy=false flask
- 数据卷备份（可选）

# 利用容器云和发镜像到 dockerhub （可选）
# 利用 docker 回滚部署版本（可选）
# 多容器部署 （可选）
- 从 docker hub 下一个容器化的 mysql
- 普通手动版本
- docker compose

# 实例项目：利用 docker + jenkins + github pr 打造 CI/CD 持续集成/持续部署
    介绍 github pr 流程
    介绍 jenkins 和 ci
    
    1. 开发写完代码开 pr
    2. 开了 pr 之后会自动在 jenkins 跑一个 build （利用 jenkins github 插件）
    3. 这个 build 开一个 docker 容器 （jenkins docker 插件），从 pr 的分支拉了代码后跑自动部署和测试
    4. 部署和测试的结果会显示在 pr 页面
    5. pr 合并到 master 后，master 代码会被自动部署到生产服务器 （可选）


jenkins java 版本有要求，并且国内没有 ubuntu 镜像 所以就直接装 docker 版本的就好了 还有镜像加速
docker volume create jenkins-volume
docker run -p 5000:5000 -p 8080:8080 --name jenkins --mount source=jenkins-volume,target=/var/jenkins_home --sig-proxy=false jenkins/jenkins:lts

echo runtime info
whoami
ls -al
env

echo docker begin
sudo docker build -t "flask:build${BUILD_NUMBER}" -t flask:latest .
sudo docker stop "flask:pr${GITHUB_PR_NUMBER}" || true sudo docker rm "flask:pr${GITHUB_PR_NUMBER}" || true
container=$(sudo docker run -P -d --name "flask:pr${GITHUB_PR_NUMBER}" "flask:build${BUILD_NUMBER}")
bind=$(sudo docker port ${container} 5000)
port=${bind:8}
export DOCKER_URL="http://docker.kuaibiancheng.com:${port}/"

Build ${BUILD_NUMBER} ${BUILD_STATUS} ${BUILD_URL}console  ${DOCKER_URL}


usermod -a -G sudo jenkins
/etc/sudoers
jenkins ALL= NOPASSWD: ALL

ufw allow 32768:60999/tcp
ufw default deny incoming
ufw default allow outgoing
ufw status verbose




